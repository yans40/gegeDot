<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GegeDot - Vue √âventail Professionnelle</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }

        .header h1 {
            margin-bottom: 10px;
        }

        .controls {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 15px;
            margin-bottom: 30px;
            flex-wrap: wrap;
        }

        .person-selector {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .person-selector label {
            font-weight: 600;
            color: #333;
        }

        .person-selector select {
            padding: 10px 15px;
            border: 2px solid #ddd;
            border-radius: 6px;
            font-size: 14px;
            min-width: 250px;
            background: white;
        }

        .controls button {
            padding: 12px 24px;
            font-size: 16px;
            cursor: pointer;
            border: none;
            border-radius: 8px;
            color: white;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .controls button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }

        .controls button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .zoom-controls {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-left: 20px;
        }

        .zoom-controls button {
            padding: 8px 16px;
            font-size: 14px;
            min-width: 45px;
        }

        .zoom-controls span {
            font-weight: bold;
            color: #667eea;
            min-width: 60px;
            text-align: center;
        }

        .visualization-container {
            position: relative;
            width: 100%;
            height: calc(100vh - 250px);
            min-height: 600px;
            background: white;
            border-radius: 10px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.1);
            overflow: hidden;
        }

        .fan-viewport {
            position: relative;
            width: 100%;
            height: 100%;
            overflow: auto;
            cursor: grab;
        }

        .fan-viewport:active {
            cursor: grabbing;
        }

        .fan-content {
            position: relative;
            min-width: 3000px;
            min-height: 1500px;
            transform-origin: 0 0;
            transition: transform 0.3s ease;
        }

        /* Styles pour les cartes g√©n√©alogiques professionnelles */
        .genealogy-card {
            position: absolute;
            width: 200px;
            min-height: 180px;
            background: white;
            border: 2px solid #667eea;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            padding: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
            opacity: 0;
            transform: scale(0.8);
            z-index: 5; /* Au-dessus des connexions */
        }

        .genealogy-card.visible {
            opacity: 1;
            transform: scale(1);
        }

        .genealogy-card:hover {
            transform: scale(1.05);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.3);
            z-index: 10;
        }

        .genealogy-card.clickable {
            cursor: pointer;
        }

        .genealogy-card.clickable:hover {
            transform: scale(1.08);
            box-shadow: 0 8px 25px rgba(102, 126, 234, 0.4);
            border-color: #F39C12;
        }

        .genealogy-card.central.clickable:hover {
            border-color: #E67E22;
            box-shadow: 0 8px 25px rgba(243, 156, 18, 0.5);
        }

        .genealogy-card.sibling {
            opacity: 0.6;
            background: #f5f5f5;
            border-color: #999;
            border-style: dashed;
        }

        .genealogy-card.sibling:hover {
            opacity: 0.9;
            transform: scale(1.08);
            box-shadow: 0 8px 25px rgba(153, 153, 153, 0.4);
            border-color: #667eea;
            border-style: solid;
        }

        .genealogy-card.sibling.clickable {
            cursor: pointer;
        }

        /* Style pour les enfants : plus petits et plus gris√©s */
        .genealogy-card.child {
            width: 160px;
            min-height: 140px;
            opacity: 0.4;
            background: #e8e8e8;
            border-color: #999;
            border-style: dashed;
            font-size: 0.9em;
        }

        .genealogy-card.child .card-name {
            font-size: 13px;
        }

        .genealogy-card.child .card-details {
            font-size: 10px;
        }

        .genealogy-card.child .card-id {
            font-size: 9px;
        }

        .genealogy-card.child .card-profession {
            font-size: 10px;
        }

        .genealogy-card.child:hover {
            opacity: 0.7;
            transform: scale(1.05);
            box-shadow: 0 6px 20px rgba(153, 153, 153, 0.4);
            border-color: #667eea;
            border-style: solid;
        }

        .genealogy-card.child.clickable {
            cursor: pointer;
        }

        .genealogy-card.male {
            border-color: #4A90E2;
        }

        .genealogy-card.female {
            border-color: #E24A90;
        }

        .genealogy-card.central {
            border-color: #F39C12;
            border-width: 3px;
            position: relative;
        }

        /* Ic√¥ne c≈ìur pour afficher le conjoint */
        .spouse-heart-icon {
            position: absolute;
            top: 10px;
            right: 10px;
            font-size: 20px;
            color: #E24A90;
            cursor: pointer;
            transition: all 0.3s ease;
            z-index: 10;
            opacity: 0.7;
        }

        .spouse-heart-icon:hover {
            opacity: 1;
            transform: scale(1.2);
            color: #FF4081;
        }

        .spouse-heart-icon.active {
            opacity: 1;
            color: #FF4081;
            animation: heartbeat 1s ease-in-out infinite;
        }

        @keyframes heartbeat {
            0%, 100% {
                transform: scale(1);
            }
            50% {
                transform: scale(1.15);
            }
        }

        /* Carte du conjoint avec animation */
        .genealogy-card.spouse {
            border-color: #9C27B0;
            border-width: 2px;
            background: white;
            opacity: 0;
            transform: translateX(-20px);
            transition: all 0.4s cubic-bezier(0.68, -0.55, 0.265, 1.55);
            z-index: 6;
        }

        .genealogy-card.spouse.visible {
            opacity: 1;
            transform: translateX(0);
        }

        .genealogy-card.spouse:hover {
            border-color: #7B1FA2;
            box-shadow: 0 6px 20px rgba(156, 39, 176, 0.3);
        }

        /* Ligne de connexion mariage */
        .connection-marriage-spouse {
            background: #E24A90 !important;
            opacity: 0;
            transition: opacity 0.4s ease;
            z-index: 1;
        }

        .connection-marriage-spouse.visible {
            opacity: 0.8;
        }

        .card-id {
            font-size: 11px;
            font-weight: bold;
            color: #667eea;
            margin-bottom: 5px;
        }

        .card-name {
            font-size: 15px;
            font-weight: bold;
            color: #333;
            margin-bottom: 8px;
            text-align: center;
            padding-bottom: 8px;
            border-bottom: 1px solid #eee;
        }

        .card-profession {
            font-size: 12px;
            color: #666;
            font-style: italic;
            margin-bottom: 8px;
            text-align: center;
        }

        .card-details {
            font-size: 11px;
            color: #555;
            line-height: 1.6;
        }

        .card-detail-line {
            margin-bottom: 4px;
            display: flex;
            align-items: flex-start;
        }

        .card-detail-icon {
            margin-right: 6px;
            font-weight: bold;
            min-width: 12px;
        }

        .card-detail-text {
            flex: 1;
        }

        /* Connexions familiales */
        .family-connection {
            position: absolute;
            background: #333;
            z-index: 1;
            pointer-events: none;
        }

        .connection-parent-child {
            width: 2px;
            background: #4A90E2;
        }

        .connection-marriage {
            height: 2px;
            background: #E24A90;
        }

        /* Connexions vers les enfants - gris √† angle droit sans croix */
        .connection-to-child {
            background: #999 !important; /* Gris */
            opacity: 0.6;
            transition: opacity 0.3s ease;
        }

        .connection-to-child:hover {
            opacity: 0.9;
        }

        .status {
            text-align: center;
            padding: 15px;
            margin: 20px 0;
            border-radius: 8px;
            display: none;
        }

        .status.loading {
            display: block;
            background: #e3f2fd;
            color: #1976d2;
        }

        .status.success {
            display: block;
            background: #e8f5e9;
            color: #388e3c;
        }

        .status.error {
            display: block;
            background: #ffebee;
            color: #d32f2f;
        }

        /* L√©gende */
        .legend {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.15);
            z-index: 1000;
            max-width: 250px;
            border: 1px solid #e0e0e0;
        }

        .legend h4 {
            margin: 0 0 10px 0;
            color: #667eea;
            font-size: 14px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
            font-size: 12px;
        }

        .legend-color {
            width: 20px;
            height: 20px;
            border: 2px solid #333;
            margin-right: 8px;
            border-radius: 4px;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>üå≥ GegeDot - Vue √âventail Professionnelle</h1>
        <p>Visualisation hi√©rarchique par g√©n√©rations avec informations compl√®tes</p>
    </div>

    <div class="controls">
        <div class="person-selector">
            <label for="personSelect">üë§ Personne :</label>
            <select id="personSelect">
                <option value="">-- S√©lectionnez une personne --</option>
            </select>
        </div>
        <button id="loadTreeBtn" onclick="loadFanView()">üå≥ Charger la Vue √âventail</button>
        <button onclick="loadPersons()" style="background: linear-gradient(135deg, #28a745 0%, #20c997 100%);">üîÑ Recharger les personnes</button>
        <div class="zoom-controls">
            <button onclick="zoomOut()">üîç-</button>
            <button onclick="resetZoom()">üéØ</button>
            <button onclick="zoomIn()">üîç+</button>
            <span id="zoomLevel">100%</span>
        </div>
    </div>

    <div id="status" class="status"></div>

    <div style="text-align: center; margin: 15px 0; padding: 10px; background: #e3f2fd; border-radius: 6px; color: #1976d2; font-size: 13px;">
        üí° <strong>Astuce :</strong> Cliquez sur n'importe quelle carte (parents, grands-parents, fr√®res/s≈ìurs, enfants) pour voir la vue √©ventail de cette personne. Les cartes gris√©es en pointill√©s sont les fr√®res/s≈ìurs et enfants (cliquables).
    </div>

    <div class="visualization-container">
        <div class="fan-viewport" id="fanViewport">
            <div class="fan-content" id="fanContent"></div>
        </div>
    </div>

    <div class="legend">
        <h4>üìã L√©gende</h4>
        <div class="legend-item">
            <div class="legend-color" style="background: white; border-color: #F39C12;"></div>
            <span>Personne centrale</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #f5f5f5; border-color: #999; border-style: dashed; opacity: 0.6;"></div>
            <span>Fr√®re/S≈ìur (cliquable)</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #f5f5f5; border-color: #999; border-style: dashed; opacity: 0.6;"></div>
            <span>Enfant (cliquable)</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: white; border-color: #4A90E2;"></div>
            <span>Homme</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: white; border-color: #E24A90;"></div>
            <span>Femme</span>
        </div>
        <div class="legend-item">
            <div style="width: 20px; height: 2px; background: #4A90E2; margin-right: 8px;"></div>
            <span>Lien parent-enfant</span>
        </div>
        <div class="legend-item">
            <div style="width: 20px; height: 2px; background: #E24A90; margin-right: 8px;"></div>
            <span>Lien mariage</span>
        </div>
    </div>

    <script>
        const API_BASE_URL = 'http://localhost:5001/api';
        let currentZoom = 1;
        let currentPanX = 0;
        let currentPanY = 0;
        let isDragging = false;
        let dragStartX = 0;
        let dragStartY = 0;
        let allCards = [];
        let allConnections = [];
        let familyTreeData = null;

        // Charger la liste des personnes
        async function loadPersons() {
            try {
                const response = await fetch(`${API_BASE_URL}/persons`);
                if (!response.ok) throw new Error('Erreur lors du chargement des personnes');
                
                const persons = await response.json();
                const select = document.getElementById('personSelect');
                if (!select) {
                    console.error('√âl√©ment personSelect non trouv√©');
                    return;
                }
                
                select.innerHTML = '<option value="">-- S√©lectionnez une personne --</option>';
                
                persons.forEach(person => {
                    const option = document.createElement('option');
                    option.value = person.id;
                    option.textContent = `${person.fullName} (ID: ${person.id})`;
                    select.appendChild(option);
                });
                
                updateStatus(`${persons.length} personnes charg√©es`, 'success');
                setTimeout(() => {
                    document.getElementById('status').style.display = 'none';
                }, 2000);
            } catch (error) {
                console.error('Erreur:', error);
                updateStatus('Erreur lors du chargement des personnes', 'error');
            }
        }

        // Charger la vue √©ventail
        async function loadFanView() {
            const personId = document.getElementById('personSelect').value;
            if (!personId) {
                updateStatus('Veuillez s√©lectionner une personne', 'error');
                return;
            }

            await loadFanViewForPerson(personId);
        }

        // Charger la vue √©ventail pour une personne sp√©cifique
        async function loadFanViewForPerson(personId, personName = null) {
            if (!personId) {
                updateStatus('ID de personne invalide', 'error');
                return;
            }

            updateStatus('Chargement...', 'loading');
            
            // Supprimer TOUTES les cartes de conjoint et connexions AVANT de charger la nouvelle vue
            const content = document.getElementById('fanContent');
            const allSpouseCards = content.querySelectorAll('.genealogy-card.spouse');
            allSpouseCards.forEach(card => {
                if (card.parentNode) {
                    card.remove();
                }
            });
            const allMarriageConnections = content.querySelectorAll('.connection-marriage-spouse');
            allMarriageConnections.forEach(conn => {
                if (conn.parentNode) {
                    conn.remove();
                }
            });
            
            try {
                const response = await fetch(`${API_BASE_URL}/persons/${personId}/family`);
                if (!response.ok) throw new Error('Erreur lors du chargement des donn√©es familiales');
                
                const familyData = await response.json();
                familyTreeData = familyData;
                
                // Mettre √† jour le s√©lecteur de personne
                const personSelect = document.getElementById('personSelect');
                if (personSelect) {
                    personSelect.value = personId;
                }
                
                // R√©initialiser le zoom et le pan
                currentZoom = 1;
                currentPanX = 0;
                currentPanY = 0;
                updateViewport();
                
                await renderFanView(familyData);
                
                const displayName = personName || familyData.person?.fullName || `Personne ${personId}`;
                updateStatus(`Vue √©ventail de "${displayName}" charg√©e avec succ√®s`, 'success');
                setTimeout(() => {
                    document.getElementById('status').style.display = 'none';
                }, 2000);
            } catch (error) {
                console.error('Erreur:', error);
                updateStatus('Erreur lors du chargement', 'error');
            }
        }

        // Rendre la vue √©ventail avec structure hi√©rarchique
        async function renderFanView(familyData) {
            const content = document.getElementById('fanContent');
            
            // Supprimer explicitement toutes les cartes de conjoint et connexions de mariage AVANT de vider le contenu
            const existingSpouseCards = content.querySelectorAll('.genealogy-card.spouse');
            existingSpouseCards.forEach(card => {
                if (card.parentNode) {
                    card.remove();
                }
            });
            const existingMarriageConnections = content.querySelectorAll('.connection-marriage-spouse');
            existingMarriageConnections.forEach(conn => {
                if (conn.parentNode) {
                    conn.remove();
                }
            });
            
            // Vider compl√®tement le contenu
            content.innerHTML = '';
            allCards = [];
            allConnections = [];
            
            // R√©initialiser toutes les r√©f√©rences de conjoint pour √©viter les doublons
            // (les variables locales dans setupSpouseInteraction seront r√©initialis√©es lors du prochain appel)
            
            // Note: Le code SVG avec courbes est conserv√© dans PROPOSITION_DESIGN_LIENS_ENFANTS.md
            // pour r√©f√©rence future si besoin

            updateStatus('Construction de l\'arbre g√©n√©alogique...', 'loading');

            // Construire l'arbre complet par g√©n√©rations (r√©cursif)
            const { generations, familyDataCache } = await buildGenerations(familyData, 4);
            
            if (generations.length === 0) {
                updateStatus('Aucune donn√©e √† afficher', 'error');
                return;
            }

            // Configuration de positionnement adaptatif
            const levelHeight = 220; // Espacement vertical entre g√©n√©rations
            const baseCardSpacing = 250; // Espacement horizontal de base
            const startY = 50; // Position Y de d√©part (pour les g√©n√©rations les plus hautes)
            const cardWidth = 200; // Largeur d'une carte
            const minSpacing = cardWidth + 30; // Espacement minimum entre cartes (largeur + marge)
            
            // Trouver les niveaux min et max (pour g√©rer les niveaux n√©gatifs des enfants)
            const levels = Object.keys(generations).map(Number).sort((a, b) => a - b);
            const minLevel = Math.min(...levels);
            const maxLevel = Math.max(...levels);
            
            // Calculer la position Y de base pour la personne centrale
            // La personne centrale est au niveau 0, on la place en bas des ascendants
            // Si on a des enfants (niveau -1), la personne centrale sera au milieu
            const centralPersonY = startY + (maxLevel * levelHeight); // Personne centrale en bas des ascendants

            // Stocker les positions calcul√©es et les relations parent-enfant
            const cardPositions = new Map();
            const parentChildMap = new Map(); // Map: childId -> [parentIds]
            const childParentMap = new Map(); // Map: parentId -> [childIds] (pour les enfants)
            const personLevelMap = new Map(); // Map: personId -> level

            // Cr√©er une map des niveaux pour chaque personne (incluant les niveaux n√©gatifs)
            for (const level of levels) {
                const generation = generations[level];
                if (generation) {
                    for (const personData of generation) {
                        personLevelMap.set(personData.person.id, level);
                    }
                }
            }

            // Construire la map des relations parent-enfant en utilisant le cache des donn√©es familiales
            for (const level of levels) {
                const generation = generations[level];
                if (!generation) continue;
                
                for (const personData of generation) {
                    const personId = personData.person.id;
                    const personFamilyData = familyDataCache.get(personId);
                    
                    if (personFamilyData && personFamilyData.parents && personFamilyData.parents.length > 0) {
                        // Filtrer pour ne garder que les parents qui sont dans une g√©n√©ration sup√©rieure
                        const parentsInView = personFamilyData.parents
                            .filter(parent => {
                                const parentLevel = personLevelMap.get(parent.id);
                                return parentLevel !== undefined && parentLevel > level;
                            })
                            .map(p => p.id);
                        
                        if (parentsInView.length > 0) {
                            parentChildMap.set(personId, parentsInView);
                            console.log(`üìã ${personData.person.fullName} (niveau ${level}) a ${parentsInView.length} parent(s) dans la vue:`, parentsInView);
                        }
                    }
                }
            }
            
            // Construire la map des relations enfant-parent (pour les enfants de la personne centrale)
            const childrenGeneration = generations[-1];
            if (childrenGeneration) {
                const centralPersonId = familyData.person.id;
                const childrenIds = childrenGeneration.map(c => c.person.id);
                childParentMap.set(centralPersonId, childrenIds);
                console.log(`üë∂ ${familyData.person.fullName} a ${childrenIds.length} enfant(s) dans la vue:`, childrenIds);
            }

            // Debug: Afficher la structure des g√©n√©rations
            console.log('üìä Structure des g√©n√©rations:');
            for (const level of levels) {
                const gen = generations[level];
                if (gen) {
                    console.log(`  Niveau ${level}: ${gen.length} personne(s) - ${gen.map(p => p.person.fullName).join(', ')}`);
                }
            }
            console.log('üìã Map parent-enfant:', Array.from(parentChildMap.entries()));
            console.log('üë∂ Map enfant-parent:', Array.from(childParentMap.entries()));

            // Calculer les positions en partant de la g√©n√©ration la plus haute
            // et en descendant niveau par niveau, en centrant chaque personne par rapport √† ses parents
            for (let level = maxLevel; level >= minLevel; level--) {
                const generation = generations[level];
                if (!generation) continue;
                
                // G√©rer les enfants (niveau -1) : positionner en dessous de la personne centrale
                if (level === -1) {
                    const centralPersonId = familyData.person.id;
                    const centralPersonX = cardPositions.get(centralPersonId) || 1500;
                    const centralPersonCenterX = centralPersonX + (cardWidth / 2);
                    
                    // Centrer les enfants par rapport √† la personne centrale
                    // Les cartes enfants font 160px de large (plus petites)
                    const childCardWidth = 160;
                    const childSpacing = Math.max(baseCardSpacing, minSpacing);
                    const totalGroupWidth = (generation.length - 1) * childSpacing + childCardWidth;
                    const groupStartX = centralPersonCenterX - (totalGroupWidth / 2);
                    
                    generation.forEach((childData, index) => {
                        const childX = groupStartX + (index * childSpacing);
                        cardPositions.set(childData.person.id, childX);
                    });
                    
                    console.log(`üë∂ ${generation.length} enfant(s) centr√©(s) par rapport √† ${familyData.person.fullName}`);
                    continue;
                }
                
                if (level === maxLevel) {
                    // Derni√®re g√©n√©ration (la plus haute) : positionner s√©quentiellement
                    const cardSpacing = Math.max(baseCardSpacing, minSpacing);
                    const totalWidth = (generation.length - 1) * cardSpacing;
                    const startX = 1500 - (totalWidth / 2);
                    
                    generation.forEach((personData, index) => {
                        const x = startX + (index * cardSpacing);
                        cardPositions.set(personData.person.id, x);
                    });
                } else {
                    // Pour les autres g√©n√©rations, grouper les enfants par parents communs
                    // et les centrer collectivement pour √©viter les probl√®mes de chevauchement
                    
                    // Grouper les personnes par leurs parents (cl√© = ensemble tri√© des IDs des parents)
                    const childrenByParents = new Map();
                    
                    for (const personData of generation) {
                        const personId = personData.person.id;
                        const parentIds = parentChildMap.get(personId) || [];
                        
                        if (parentIds.length > 0) {
                            // Cr√©er une cl√© unique pour ce groupe de parents
                            const parentKey = parentIds.sort((a, b) => a - b).join(',');
                            
                            if (!childrenByParents.has(parentKey)) {
                                childrenByParents.set(parentKey, {
                                    parentIds: parentIds,
                                    children: []
                                });
                            }
                            
                            childrenByParents.get(parentKey).children.push(personData);
                        } else {
                            // Pas de parents, traiter individuellement
                            const index = generation.findIndex(p => p.person.id === personId);
                            const cardSpacing = Math.max(baseCardSpacing, minSpacing);
                            const totalWidth = (generation.length - 1) * cardSpacing;
                            const startX = 1500 - (totalWidth / 2);
                            cardPositions.set(personId, startX + (index * cardSpacing));
                        }
                    }
                    
                    // Pour chaque groupe d'enfants avec les m√™mes parents, centrer le groupe
                    childrenByParents.forEach((group, parentKey) => {
                        const { parentIds, children } = group;
                        
                        // Calculer le centre des parents
                        const parentPositions = parentIds
                            .map(pid => cardPositions.get(pid))
                            .filter(pos => pos !== undefined);
                        
                        if (parentPositions.length > 0) {
                            const parentCenters = parentPositions.map(pos => pos + (cardWidth / 2));
                            const averageCenterX = parentCenters.reduce((sum, center) => sum + center, 0) / parentCenters.length;
                            
                            // Si un seul enfant, le centrer directement
                            if (children.length === 1) {
                                const childLeftX = averageCenterX - (cardWidth / 2);
                                cardPositions.set(children[0].person.id, childLeftX);
                                console.log(`‚úÖ ${children[0].person.fullName} (niveau ${level}) centr√© √† ${childLeftX} par rapport √† ${parentIds.length} parent(s)`);
                            } else {
                                // Plusieurs enfants : centrer le groupe, puis espacer les enfants
                                const childSpacing = Math.max(baseCardSpacing, minSpacing);
                                // Largeur totale du groupe = (nombre d'enfants - 1) * espacement + largeur d'une carte
                                const totalGroupWidth = (children.length - 1) * childSpacing + cardWidth;
                                // Position du coin gauche du premier enfant pour que le centre du groupe soit √† averageCenterX
                                const groupStartX = averageCenterX - (totalGroupWidth / 2);
                                
                                children.forEach((childData, index) => {
                                    const childX = groupStartX + (index * childSpacing);
                                    cardPositions.set(childData.person.id, childX);
                                });
                                
                                // V√©rifier le centrage
                                const firstChildX = cardPositions.get(children[0].person.id);
                                const lastChildX = cardPositions.get(children[children.length - 1].person.id);
                                const groupCenterX = (firstChildX + lastChildX + cardWidth) / 2;
                                
                                console.log(`‚úÖ Groupe de ${children.length} enfants centr√© √† ${groupCenterX} (id√©al: ${averageCenterX}, diff: ${Math.abs(groupCenterX - averageCenterX).toFixed(1)}px) par rapport √† ${parentIds.length} parent(s): ${children.map(c => c.person.fullName).join(', ')}`);
                            }
                        } else {
                            // Parents non trouv√©s, positionner s√©quentiellement
                            const cardSpacing = Math.max(baseCardSpacing, minSpacing);
                            const totalWidth = (children.length - 1) * cardSpacing;
                            const startX = 1500 - (totalWidth / 2);
                            children.forEach((childData, index) => {
                                cardPositions.set(childData.person.id, startX + (index * cardSpacing));
                            });
                        }
                    });
                }
            }

            // V√©rifier et corriger les chevauchements pour chaque g√©n√©ration
            // (en pr√©servant autant que possible le centrage des groupes)
            for (const level of levels) {
                const generation = generations[level];
                if (!generation || generation.length <= 1) continue;

                // Grouper les cartes par leurs parents pour pr√©server le centrage des groupes
                const cardsByParents = new Map();
                generation.forEach(p => {
                    const parentIds = parentChildMap.get(p.person.id) || [];
                    const parentKey = parentIds.length > 0 ? parentIds.sort((a, b) => a - b).join(',') : 'no-parents';
                    
                    if (!cardsByParents.has(parentKey)) {
                        cardsByParents.set(parentKey, []);
                    }
                    cardsByParents.get(parentKey).push({
                        id: p.person.id,
                        x: cardPositions.get(p.person.id) || 1500,
                        parentIds: parentIds
                    });
                });

                // Trier toutes les cartes par position X pour d√©tecter les chevauchements
                const allCards = Array.from(cardPositions.entries())
                    .filter(([id]) => generation.some(p => p.person.id === id))
                    .map(([id, x]) => ({
                        id: id,
                        x: x,
                        parentIds: parentChildMap.get(id) || []
                    }))
                    .sort((a, b) => a.x - b.x);

                // Corriger les chevauchements en pr√©servant le centrage des groupes
                for (let i = 1; i < allCards.length; i++) {
                    const prevX = allCards[i - 1].x;
                    const currentX = allCards[i].x;
                    
                    if (currentX - prevX < minSpacing) {
                        // V√©rifier si les deux cartes ont les m√™mes parents (m√™me groupe)
                        const prevParentKey = allCards[i - 1].parentIds.sort((a, b) => a - b).join(',');
                        const currentParentKey = allCards[i].parentIds.sort((a, b) => a - b).join(',');
                        
                        if (prevParentKey === currentParentKey && prevParentKey !== '') {
                            // M√™me groupe : d√©caler tout le groupe
                            const groupCards = cardsByParents.get(prevParentKey) || [];
                            const offset = (prevX + minSpacing) - currentX;
                            
                            groupCards.forEach(card => {
                                if (card.id === allCards[i].id || card.x >= currentX) {
                                    const newX = cardPositions.get(card.id) + offset;
                                    cardPositions.set(card.id, newX);
                                    // Mettre √† jour dans allCards aussi
                                    const cardInAll = allCards.find(c => c.id === card.id);
                                    if (cardInAll) cardInAll.x = newX;
                                }
                            });
                        } else {
                            // Groupes diff√©rents : d√©caler seulement la carte actuelle
                            const newX = prevX + minSpacing;
                            cardPositions.set(allCards[i].id, newX);
                            allCards[i].x = newX;
                        }
                    }
                }
            }

            // Ajouter les siblings au niveau 0 (m√™me g√©n√©ration que la personne centrale)
            if (familyData.siblings && familyData.siblings.length > 0 && generations[0]) {
                const centralPerson = generations[0].find(p => p.isCentral);
                if (centralPerson) {
                    const siblingSpacing = 250; // Espacement entre siblings
                    
                    // Cr√©er un tableau avec la personne centrale + tous les siblings
                    const allSiblings = [
                        { person: centralPerson.person, isCentral: true },
                        ...familyData.siblings.map(s => ({ person: s, isCentral: false }))
                    ];
                    
                    // Trier tout le monde par date de naissance (du plus grand au plus jeune)
                    const sortedAll = allSiblings.sort((a, b) => {
                        // Si les deux ont une date de naissance, comparer
                        if (a.person.birthDate && b.person.birthDate) {
                            return new Date(a.person.birthDate) - new Date(b.person.birthDate);
                        }
                        // Si seulement a a une date, a est plus grand (vient en premier)
                        if (a.person.birthDate && !b.person.birthDate) {
                            return -1;
                        }
                        // Si seulement b a une date, b est plus grand (vient en premier)
                        if (!a.person.birthDate && b.person.birthDate) {
                            return 1;
                        }
                        // Si aucun n'a de date, mettre la personne centrale en premier
                        if (a.isCentral) return -1;
                        if (b.isCentral) return 1;
                        // Sinon garder l'ordre original
                        return 0;
                    });
                    
                    // Trouver l'index de la personne centrale dans l'ordre tri√©
                    const centralIndex = sortedAll.findIndex(item => item.isCentral);
                    
                    // R√©cup√©rer la position X existante de la personne centrale (d√©j√† calcul√©e)
                    const existingCentralX = cardPositions.get(centralPerson.person.id) || 1500;
                    
                    // Positionner tous les siblings dans l'ordre chronologique autour de la personne centrale
                    sortedAll.forEach((item, index) => {
                        if (item.isCentral) {
                            // La personne centrale sera rendue dans la boucle des g√©n√©rations plus bas
                            // On met juste √† jour sa position dans cardPositions pour qu'elle soit dans l'ordre chronologique
                            const offset = index - centralIndex;
                            const newCentralX = existingCentralX + (offset * siblingSpacing);
                            cardPositions.set(item.person.id, newCentralX);
                            return;
                        }
                        
                        // Calculer le d√©calage par rapport √† la position centrale
                        const offset = index - centralIndex;
                        const x = existingCentralX + (offset * siblingSpacing);
                        const y = centralPersonY; // M√™me niveau que la personne centrale (en bas)
                        
                        // Cr√©er la carte sibling
                        const card = createGenealogyCard(item.person, 0, x, y, false, true);
                        content.appendChild(card);
                        allCards.push({ 
                            card, 
                            person: item.person, 
                            generation: 0,
                            x: x,
                            y: y,
                            isSibling: true
                        });
                    });
                }
            }

            // Rendre chaque g√©n√©ration avec les positions calcul√©es
            // INVERSION : La personne centrale (level 0) est en bas, les parents au-dessus, les enfants en dessous
            for (const level of levels) {
                const generation = generations[level];
                if (!generation) continue;
                
                let y;
                if (level === -1) {
                    // Enfants : en dessous de la personne centrale
                    y = centralPersonY + levelHeight;
                } else {
                    // Ascendants : au-dessus de la personne centrale
                    y = startY + ((maxLevel - level) * levelHeight);
                }

                generation.forEach((personData) => {
                    const x = cardPositions.get(personData.person.id) || 1500;
                    // Les enfants sont gris√©s et cliquables (comme les siblings)
                    const isChild = level === -1;
                    const isSibling = false; // Les enfants ne sont pas des siblings
                    const card = createGenealogyCard(personData.person, personData.generation, x, y, personData.isCentral, isSibling, isChild);
                    content.appendChild(card);
                    allCards.push({ 
                        card, 
                        person: personData.person, 
                        generation: personData.generation,
                        x: x,
                        y: y,
                        isChild: isChild
                    });
                });
            }

            // AFFICHER LA CARTE CENTRALE EN PREMIER pour r√©duire la latence
            const centralPersonData = generations[0]?.find(p => p.isCentral);
            if (centralPersonData) {
                const centralX = cardPositions.get(centralPersonData.person.id) || 1500;
                const centralY = centralPersonY;
                
                // Trouver la carte centrale dans allCards (qui contient des objets avec une propri√©t√© card)
                const centralCardData = allCards.find(cardData => 
                    cardData.card && cardData.card.dataset.personId === String(centralPersonData.person.id)
                );
                
                if (centralCardData && centralCardData.card) {
                    const centralCard = centralCardData.card;
                    // Afficher la carte centrale imm√©diatement (sans animation)
                    centralCard.classList.add('visible');
                    centralCard.style.opacity = '1';
                    
                    // Centrer la vue imm√©diatement sur la carte centrale
                    centerOnPosition(centralX, centralY);
                    
                    // Forcer le rendu imm√©diatement
                    void content.offsetHeight; // Force reflow pour afficher imm√©diatement
                }
            }

            // Dessiner les connexions et animer les autres cartes en parall√®le
            // Utiliser requestAnimationFrame pour ne pas bloquer l'affichage de la carte centrale
            requestAnimationFrame(() => {
                drawConnections(generations, parentChildMap, childParentMap).then(() => {
                    // Apr√®s les connexions, animer les autres cartes
                    animateCards();
                });
            });
        }

        // Construire les g√©n√©rations √† partir des donn√©es familiales (r√©cursif)
        async function buildGenerations(familyData, maxDepth = 4) {
            const generations = [];
            const processed = new Map(); // Map pour stocker les personnes avec leur g√©n√©ration
            const familyDataCache = new Map(); // Cache pour les donn√©es familiales

            // Fonction r√©cursive pour charger les parents
            async function loadParentsRecursive(person, generation, maxDepth) {
                if (generation >= maxDepth || processed.has(person.id)) {
                    return;
                }

                processed.set(person.id, generation);

                // S'assurer que la g√©n√©ration existe
                if (!generations[generation]) {
                    generations[generation] = [];
                }

                // Ajouter la personne √† sa g√©n√©ration
                generations[generation].push({
                    person: person,
                    generation: generation,
                    isCentral: generation === 0
                });

                // Charger les parents si on n'a pas atteint la profondeur max
                if (generation < maxDepth - 1) {
                    try {
                        const response = await fetch(`${API_BASE_URL}/persons/${person.id}/family`);
                        if (response.ok) {
                            const parentFamilyData = await response.json();
                            // Stocker les donn√©es familiales dans le cache
                            familyDataCache.set(person.id, parentFamilyData);
                            
                            if (parentFamilyData.parents && parentFamilyData.parents.length > 0) {
                                for (const parent of parentFamilyData.parents) {
                                    await loadParentsRecursive(parent, generation + 1, maxDepth);
                                }
                            }
                        }
                    } catch (error) {
                        console.warn(`Impossible de charger les parents de ${person.id}:`, error);
                    }
                }
            }

            // Commencer avec la personne centrale
            familyDataCache.set(familyData.person.id, familyData);
            await loadParentsRecursive(familyData.person, 0, maxDepth);
            
            // Charger les enfants de la personne centrale (niveau -1)
            if (familyData.children && familyData.children.length > 0) {
                const childrenGeneration = -1;
                if (!generations[childrenGeneration]) {
                    generations[childrenGeneration] = [];
                }
                
                // Trier les enfants par date de naissance (du plus √¢g√© au plus jeune)
                const sortedChildren = [...familyData.children].sort((a, b) => {
                    const dateA = a.birthDate ? new Date(a.birthDate) : new Date('9999-12-31');
                    const dateB = b.birthDate ? new Date(b.birthDate) : new Date('9999-12-31');
                    return dateA - dateB;
                });
                
                sortedChildren.forEach(child => {
                    generations[childrenGeneration].push({
                        person: child,
                        generation: childrenGeneration,
                        isCentral: false
                    });
                });
                
                console.log(`üë∂ ${sortedChildren.length} enfant(s) charg√©(s) pour ${familyData.person.fullName}`);
            }
            
            // Retourner les g√©n√©rations et le cache des donn√©es familiales
            return { generations, familyDataCache };

            // Trier les g√©n√©rations et les personnes dans chaque g√©n√©ration
            const sortedGenerations = [];
            for (let i = 0; i < generations.length; i++) {
                if (generations[i] && generations[i].length > 0) {
                    // Trier par nom pour un affichage coh√©rent
                    generations[i].sort((a, b) => {
                        const nameA = (a.person.lastName + ' ' + a.person.firstName).toLowerCase();
                        const nameB = (b.person.lastName + ' ' + b.person.firstName).toLowerCase();
                        return nameA.localeCompare(nameB);
                    });
                    sortedGenerations.push(generations[i]);
                }
            }

            return sortedGenerations;
        }

        // Cr√©er une carte g√©n√©alogique professionnelle
        function createGenealogyCard(person, generation, x, y, isCentral, isSibling = false, isChild = false) {
            const card = document.createElement('div');
            card.className = 'genealogy-card';
            card.style.left = x + 'px';
            card.style.top = y + 'px';
            card.dataset.personId = person.id;
            card.dataset.generation = generation;

            if (isCentral) {
                card.classList.add('central');
            }
            if (isSibling) {
                card.classList.add('sibling');
            }
            if (isChild) {
                card.classList.add('child');
            }
            if (person.gender === 'Male' || person.gender === 'M') {
                card.classList.add('male');
            } else {
                card.classList.add('female');
            }

            // Formatage des dates
            const formatDate = (dateStr) => {
                if (!dateStr) return '';
                const date = new Date(dateStr);
                return date.toLocaleDateString('fr-FR', { day: 'numeric', month: 'short', year: 'numeric' });
            };

            // Formatage du lieu avec code d√©partement si disponible
            const formatPlace = (place) => {
                if (!place) return '';
                // Si le lieu contient d√©j√† un code entre parenth√®ses, on le garde
                return place;
            };

            // Ajouter l'ic√¥ne c≈ìur pour la personne centrale
            const heartIcon = isCentral ? '<div class="spouse-heart-icon" data-person-id="' + person.id + '" title="Afficher le conjoint">‚ù§Ô∏è</div>' : '';
            
            card.innerHTML = `
                ${heartIcon}
                <div class="card-id">ID: ${person.id}</div>
                <div class="card-name">${person.fullName}</div>
                ${person.profession ? `<div class="card-profession">${person.profession}</div>` : ''}
                <div class="card-details">
                    ${person.birthDate ? `
                        <div class="card-detail-line">
                            <span class="card-detail-icon">¬∞</span>
                            <span class="card-detail-text">${formatDate(person.birthDate)} ${person.birthPlace ? formatPlace(person.birthPlace) : ''}</span>
                        </div>
                    ` : ''}
                    ${person.marriageDate ? `
                        <div class="card-detail-line">
                            <span class="card-detail-icon">√ó</span>
                            <span class="card-detail-text">${formatDate(person.marriageDate)} ${person.marriagePlace ? formatPlace(person.marriagePlace) : ''}</span>
                        </div>
                    ` : ''}
                    ${person.deathDate || person.deathStatus ? `
                        <div class="card-detail-line">
                            <span class="card-detail-icon">+</span>
                            <span class="card-detail-text">
                                ${person.deathDate ? formatDate(person.deathDate) : ''} 
                                ${person.deathPlace ? formatPlace(person.deathPlace) : ''}
                                ${person.deathStatus ? ` (${person.deathStatus})` : ''}
                            </span>
                        </div>
                    ` : ''}
                </div>
            `;

            // Ajouter la classe clickable et le gestionnaire d'√©v√©nements
            // Ne pas rendre la carte centrale cliquable (elle est d√©j√† au centre)
            // Les siblings et enfants sont toujours cliquables
            if (!isCentral) {
                card.classList.add('clickable');
                if (isChild) {
                    card.title = 'Enfant - Cliquez pour voir la vue √©ventail de cette personne';
                } else if (isSibling) {
                    card.title = 'Fr√®re/S≈ìur - Cliquez pour voir la vue √©ventail de cette personne';
                } else {
                    card.title = 'Cliquez pour voir la vue √©ventail de cette personne';
                }
                card.addEventListener('click', (e) => {
                    e.stopPropagation();
                    loadFanViewForPerson(person.id, person.fullName);
                });
            } else {
                card.title = 'Personne centrale - Survolez ou cliquez sur ‚ù§Ô∏è pour voir le conjoint';
                // Ajouter les gestionnaires pour le conjoint (sera configur√© apr√®s le rendu)
                setupSpouseInteraction(card, person.id);
            }

            return card;
        }

        // Configurer l'interaction pour afficher le conjoint
        async function setupSpouseInteraction(centralCard, personId) {
            const heartIcon = centralCard.querySelector('.spouse-heart-icon');
            if (!heartIcon) return;

            // V√©rifier si les gestionnaires d'√©v√©nements ont d√©j√† √©t√© ajout√©s (√©viter les doublons)
            if (centralCard.hasAttribute('data-spouse-setup')) {
                console.log('setupSpouseInteraction d√©j√† configur√© pour cette carte, ignor√©');
                return;
            }
            centralCard.setAttribute('data-spouse-setup', 'true');

            let spouseCard = null;
            let marriageConnection = null;
            let isSpouseVisible = false;
            let spouseData = null;
            let viewLoadTime = Date.now(); // Timestamp du chargement de la vue (initialis√© lors de setupSpouseInteraction)

            // R√©cup√©rer le conjoint actuel depuis l'API
            async function loadCurrentSpouse() {
                try {
                    // Utiliser le nouvel endpoint /spouse
                    const response = await fetch(`${API_BASE_URL}/persons/${personId}/spouse`);
                    if (!response.ok) {
                        if (response.status === 404) {
                            // Pas de conjoint, c'est normal - ne pas afficher d'erreur dans la console
                            return null;
                        }
                        // Seulement logger les erreurs autres que 404
                        console.warn('Erreur lors de la r√©cup√©ration du conjoint:', response.status);
                        return null;
                    }
                    
                    return await response.json();
                } catch (error) {
                    // Ne pas logger les erreurs de r√©seau si c'est juste un 404
                    if (error.message && !error.message.includes('404')) {
                        console.warn('Impossible de charger le conjoint:', error);
                    }
                    return null;
                }
            }

            // Afficher/masquer le conjoint
            async function toggleSpouse() {
                if (!spouseData) {
                    // Charger le conjoint la premi√®re fois
                    spouseData = await loadCurrentSpouse();
                    if (!spouseData) {
                        updateStatus('Aucun conjoint actuel trouv√©', 'error');
                        setTimeout(() => {
                            document.getElementById('status').style.display = 'none';
                        }, 2000);
                        return;
                    }

                    // V√©rifier si la carte du conjoint existe d√©j√† dans le DOM (√©viter les doublons)
                    const content = document.getElementById('fanContent');
                    const existingSpouseCard = content.querySelector(`.genealogy-card.spouse[data-spouse-id="${spouseData.id}"]`);
                    if (existingSpouseCard) {
                        // La carte existe d√©j√†, ne pas la recr√©er
                        console.log('Carte du conjoint d√©j√† existante, r√©utilisation');
                        spouseCard = existingSpouseCard;
                        const existingConnection = content.querySelector(`.connection-marriage-spouse[data-spouse-id="${spouseData.id}"]`);
                        if (existingConnection) {
                            marriageConnection = existingConnection;
                        }
                        // Si la carte existe d√©j√†, on passe directement au toggle de visibilit√©
                        isSpouseVisible = !isSpouseVisible;
                        if (isSpouseVisible) {
                            heartIcon.classList.add('active');
                            setTimeout(() => {
                                if (spouseCard) spouseCard.classList.add('visible');
                                if (marriageConnection) marriageConnection.classList.add('visible');
                            }, 10);
                        } else {
                            heartIcon.classList.remove('active');
                            if (spouseCard) spouseCard.classList.remove('visible');
                            if (marriageConnection) marriageConnection.classList.remove('visible');
                        }
                        return;
                    }
                    
                    // V√©rifier qu'il n'y a pas d√©j√† une carte de conjoint pour une autre personne (nettoyage)
                    const allExistingSpouseCards = content.querySelectorAll('.genealogy-card.spouse');
                    if (allExistingSpouseCards.length > 0) {
                        console.log('Nettoyage des cartes de conjoint existantes:', allExistingSpouseCards.length);
                        allExistingSpouseCards.forEach(card => {
                            if (card.parentNode && card.getAttribute('data-spouse-id') !== String(spouseData.id)) {
                                card.remove();
                            }
                        });
                    }
                    const allExistingConnections = content.querySelectorAll('.connection-marriage-spouse');
                    if (allExistingConnections.length > 0) {
                        allExistingConnections.forEach(conn => {
                            if (conn.parentNode && conn.getAttribute('data-spouse-id') !== String(spouseData.id)) {
                                conn.remove();
                            }
                        });
                    }

                    // Cr√©er la carte du conjoint
                    // V√©rifier que la carte centrale a bien une position d√©finie
                    const centralX = parseInt(centralCard.style.left);
                    const centralY = parseInt(centralCard.style.top);
                    
                    // Si la position n'est pas d√©finie ou est invalide, ne pas cr√©er la carte
                    if (isNaN(centralX) || isNaN(centralY) || (!centralCard.style.left && !centralCard.style.top)) {
                        console.log('Carte centrale pas encore positionn√©e, report de la cr√©ation de la carte du conjoint', { centralX, centralY, hasLeft: !!centralCard.style.left, hasTop: !!centralCard.style.top });
                        return;
                    }
                    
                    // V√©rifier que les coordonn√©es sont raisonnables (pas 0,0 qui serait en haut √† gauche)
                    if (centralX === 0 && centralY === 0) {
                        console.log('Coordonn√©es de la carte centrale suspectes (0,0), report de la cr√©ation de la carte du conjoint');
                        return;
                    }
                    
                    const cardWidth = 200;
                    const spacing = 50;
                    const spouseX = centralX + cardWidth + spacing;
                    
                    // Cr√©er la carte du conjoint directement (sans passer par createGenealogyCard pour √©viter les conflits)
                    spouseCard = document.createElement('div');
                    spouseCard.className = 'genealogy-card spouse clickable';
                    spouseCard.style.position = 'absolute';
                    spouseCard.style.left = spouseX + 'px';
                    spouseCard.style.top = centralY + 'px';
                    spouseCard.setAttribute('data-spouse-id', spouseData.id);
                    spouseCard.setAttribute('data-person-id', spouseData.id);
                    spouseCard.setAttribute('data-generation', '0');
                    
                    // Ajouter les classes de genre
                    if (spouseData.gender === 'Male' || spouseData.gender === 'M') {
                        spouseCard.classList.add('male');
                    } else {
                        spouseCard.classList.add('female');
                    }
                    
                    // Formatage des dates
                    const formatDate = (dateStr) => {
                        if (!dateStr) return '';
                        const date = new Date(dateStr);
                        return date.toLocaleDateString('fr-FR', { day: 'numeric', month: 'short', year: 'numeric' });
                    };
                    
                    const formatPlace = (place) => {
                        if (!place) return '';
                        return place;
                    };
                    
                    spouseCard.innerHTML = `
                        <div class="card-id">ID: ${spouseData.id}</div>
                        <div class="card-name">${spouseData.fullName}</div>
                        ${spouseData.profession ? `<div class="card-profession">${spouseData.profession}</div>` : ''}
                        <div class="card-details">
                            ${spouseData.birthDate ? `
                                <div class="card-detail-line">
                                    <span class="card-detail-icon">¬∞</span>
                                    <span class="card-detail-text">${formatDate(spouseData.birthDate)} ${spouseData.birthPlace ? formatPlace(spouseData.birthPlace) : ''}</span>
                                </div>
                            ` : ''}
                            ${spouseData.marriageDate ? `
                                <div class="card-detail-line">
                                    <span class="card-detail-icon">√ó</span>
                                    <span class="card-detail-text">${formatDate(spouseData.marriageDate)} ${spouseData.marriagePlace ? formatPlace(spouseData.marriagePlace) : ''}</span>
                                </div>
                            ` : ''}
                            ${spouseData.deathDate || spouseData.deathStatus ? `
                                <div class="card-detail-line">
                                    <span class="card-detail-icon">+</span>
                                    <span class="card-detail-text">
                                        ${spouseData.deathDate ? formatDate(spouseData.deathDate) : ''} 
                                        ${spouseData.deathPlace ? formatPlace(spouseData.deathPlace) : ''}
                                        ${spouseData.deathStatus ? ` (${spouseData.deathStatus})` : ''}
                                    </span>
                                </div>
                            ` : ''}
                        </div>
                    `;
                    
                    spouseCard.title = 'Conjoint - Cliquez pour voir la vue √©ventail de cette personne';
                    
                    spouseCard.addEventListener('click', (e) => {
                        e.stopPropagation();
                        e.preventDefault();
                        
                        // Marquer qu'une vue est en cours de chargement pour emp√™cher le survol automatique
                        if (centralCard._setViewLoading) {
                            centralCard._setViewLoading(true);
                        }
                        
                        // Sauvegarder l'ID et le nom du conjoint avant de supprimer
                        const spouseIdToLoad = spouseData.id;
                        const spouseNameToLoad = spouseData.fullName;
                        
                        // Supprimer explicitement TOUTES les cartes de conjoint et connexions avant de charger la nouvelle vue
                        const content = document.getElementById('fanContent');
                        const allSpouseCards = content.querySelectorAll('.genealogy-card.spouse');
                        allSpouseCards.forEach(card => {
                            if (card.parentNode) {
                                card.remove();
                            }
                        });
                        const allMarriageConnections = content.querySelectorAll('.connection-marriage-spouse');
                        allMarriageConnections.forEach(conn => {
                            if (conn.parentNode) {
                                conn.remove();
                            }
                        });
                        
                        // R√©initialiser les variables pour √©viter les doublons
                        spouseCard = null;
                        marriageConnection = null;
                        isSpouseVisible = false;
                        spouseData = null;
                        
                        // Attendre un peu pour s'assurer que le DOM est nettoy√© avant de charger la nouvelle vue
                        setTimeout(async () => {
                            try {
                                await loadFanViewForPerson(spouseIdToLoad, spouseNameToLoad);
                                // R√©initialiser le flag apr√®s le chargement
                                if (centralCard._setViewLoading) {
                                    setTimeout(() => {
                                        centralCard._setViewLoading(false);
                                    }, 1000); // Attendre 1 seconde apr√®s le chargement
                                }
                            } catch (error) {
                                console.error('Erreur lors du chargement de la vue:', error);
                                // R√©initialiser le flag m√™me en cas d'erreur
                                if (centralCard._setViewLoading) {
                                    centralCard._setViewLoading(false);
                                }
                            }
                        }, 50);
                    });
                    
                    content.appendChild(spouseCard);
                    
                    // Cr√©er la ligne de connexion
                    marriageConnection = document.createElement('div');
                    marriageConnection.className = 'family-connection connection-marriage-spouse';
                    marriageConnection.setAttribute('data-spouse-id', spouseData.id);
                    marriageConnection.style.left = (centralX + cardWidth) + 'px';
                    marriageConnection.style.top = (centralY + 90) + 'px'; // Milieu vertical
                    marriageConnection.style.width = spacing + 'px';
                    marriageConnection.style.height = '2px';
                    marriageConnection.style.background = '#E24A90';
                    content.appendChild(marriageConnection);
                }

                // Toggle visibility
                isSpouseVisible = !isSpouseVisible;
                
                if (isSpouseVisible) {
                    heartIcon.classList.add('active');
                    setTimeout(() => {
                        spouseCard.classList.add('visible');
                        marriageConnection.classList.add('visible');
                    }, 10);
                } else {
                    heartIcon.classList.remove('active');
                    spouseCard.classList.remove('visible');
                    marriageConnection.classList.remove('visible');
                }
            }

            // Gestionnaires d'√©v√©nements
            heartIcon.addEventListener('click', (e) => {
                e.stopPropagation();
                toggleSpouse();
            });

            // Survol de la carte centrale pour afficher le conjoint
            let hoverTimeout = null;
            let isHovering = false;
            let isViewLoading = false; // Flag pour emp√™cher le survol pendant le chargement d'une nouvelle vue
            
            centralCard.addEventListener('mouseenter', () => {
                // Ne pas d√©clencher le survol si une vue est en cours de chargement
                if (isViewLoading) {
                    return;
                }
                
                // Ne pas d√©clencher le survol automatique dans les 2 secondes suivant le chargement de la vue
                const timeSinceLoad = Date.now() - viewLoadTime;
                if (timeSinceLoad < 2000) {
                    return;
                }
                
                // V√©rifier que la carte centrale a bien une position d√©finie
                const centralX = parseInt(centralCard.style.left) || 0;
                const centralY = parseInt(centralCard.style.top) || 0;
                if (centralX === 0 && centralY === 0 && !centralCard.style.left && !centralCard.style.top) {
                    return; // La carte n'est pas encore positionn√©e
                }
                
                isHovering = true;
                hoverTimeout = setTimeout(() => {
                    // V√©rifier que la carte est toujours dans le DOM et qu'on est toujours en survol
                    if (isHovering && !isSpouseVisible && spouseData && centralCard.parentNode && !isViewLoading) {
                        // V√©rifier qu'il n'y a pas d√©j√† une carte de conjoint pour cette personne
                        const content = document.getElementById('fanContent');
                        const existingSpouse = content.querySelector(`.genealogy-card.spouse[data-spouse-id="${spouseData.id}"]`);
                        if (!existingSpouse) {
                            toggleSpouse();
                        }
                    }
                }, 500); // D√©lai de 500ms avant d'afficher
            });

            centralCard.addEventListener('mouseleave', () => {
                isHovering = false;
                if (hoverTimeout) {
                    clearTimeout(hoverTimeout);
                    hoverTimeout = null;
                }
            });
            
            // Exposer isViewLoading pour qu'il puisse √™tre modifi√© depuis le gestionnaire de clic
            centralCard._isViewLoading = () => isViewLoading;
            centralCard._setViewLoading = (value) => { isViewLoading = value; };
        }

        // Dessiner les connexions familiales (utilise les positions d√©j√† calcul√©es et centr√©es)
        async function drawConnections(generations, parentChildMap, childParentMap) {
            const content = document.getElementById('fanContent');

            // Dessiner les connexions ascendantes (parents ‚Üí enfants)
            const levels = Object.keys(generations).map(Number).sort((a, b) => a - b);
            for (const level of levels) {
                const currentGeneration = generations[level];
                if (!currentGeneration) continue;

                for (const personData of currentGeneration) {
                    const personId = personData.person.id;
                    const card = document.querySelector(`[data-person-id="${personId}"]`);
                    
                    if (!card) continue;

                    const parentIds = parentChildMap ? parentChildMap.get(personId) || [] : [];
                    
                    if (parentIds.length > 0) {
                        // INVERSION : Les parents sont maintenant AU-DESSUS des enfants
                        const childX = parseInt(card.style.left) + 100; // Centre de la carte enfant
                        const childTopY = parseInt(card.style.top); // Haut de la carte enfant (les enfants sont en bas)
                        const childBottomY = childTopY + 180; // Bas de la carte enfant

                        // R√©cup√©rer les cartes des parents
                        const parentCards = parentIds
                            .map(pid => document.querySelector(`[data-person-id="${pid}"]`))
                            .filter(c => c !== null);

                        if (parentCards.length > 0) {
                            // Calculer le centre entre tous les parents (d√©j√† centr√©s)
                            const parentXs = parentCards.map(c => parseInt(c.style.left) + 100);
                            const parentTopYs = parentCards.map(c => parseInt(c.style.top)); // Haut des cartes parents
                            const parentBottomYs = parentCards.map(c => parseInt(c.style.top) + 180); // Bas des cartes parents
                            const minParentX = Math.min(...parentXs);
                            const maxParentX = Math.max(...parentXs);
                            const midX = (minParentX + maxParentX) / 2;
                            const maxParentBottomY = Math.max(...parentBottomYs); // Bas des parents (ils sont au-dessus, donc Y plus petit)
                            
                            // Point de connexion vertical (en dessous des cartes parents, au-dessus de l'enfant)
                            const connectionY = maxParentBottomY + 20; // 20px en dessous du bas des cartes parents

                            // Ligne horizontale de l'enfant vers le centre (si n√©cessaire)
                            // Cette ligne part du centre de l'enfant vers le point de connexion centr√©
                            if (Math.abs(childX - midX) > 5) {
                                const horizontalFromChild = document.createElement('div');
                                horizontalFromChild.className = 'family-connection connection-parent-child';
                                horizontalFromChild.style.left = Math.min(childX, midX) + 'px';
                                horizontalFromChild.style.top = connectionY + 'px';
                                horizontalFromChild.style.width = Math.abs(childX - midX) + 'px';
                                horizontalFromChild.style.height = '2px';
                                content.appendChild(horizontalFromChild);
                                allConnections.push(horizontalFromChild);
                            }

                            // Ligne verticale depuis le point de connexion (centr√© entre les parents) vers le haut de l'enfant
                            // Cette ligne part toujours du point de connexion centr√© (midX), pas du centre de l'enfant
                            const verticalToChild = document.createElement('div');
                            verticalToChild.className = 'family-connection connection-parent-child';
                            verticalToChild.style.left = (midX - 1) + 'px'; // Centr√© entre les parents
                            verticalToChild.style.top = connectionY + 'px';
                            verticalToChild.style.height = Math.max(0, childTopY - connectionY) + 'px'; // Vers le bas (hauteur positive)
                            verticalToChild.style.width = '2px';
                            content.appendChild(verticalToChild);
                            allConnections.push(verticalToChild);

                            // Ligne horizontale en dessous des parents
                            const horizontalBottom = document.createElement('div');
                            horizontalBottom.className = 'family-connection connection-parent-child';
                            horizontalBottom.style.left = minParentX + 'px';
                            horizontalBottom.style.top = connectionY + 'px';
                            horizontalBottom.style.width = (maxParentX - minParentX) + 'px';
                            horizontalBottom.style.height = '2px';
                            content.appendChild(horizontalBottom);
                            allConnections.push(horizontalBottom);

                            // Lignes verticales depuis chaque parent vers le point de connexion (vers le bas)
                            parentCards.forEach((parentCard) => {
                                const parentX = parseInt(parentCard.style.left) + 100;
                                const parentBottomY = parseInt(parentCard.style.top) + 180; // Bas de la carte parent
                                
                                // Ligne verticale depuis le bas du parent vers le point de connexion
                                const verticalFromParent = document.createElement('div');
                                verticalFromParent.className = 'family-connection connection-parent-child';
                                verticalFromParent.style.left = (parentX - 1) + 'px';
                                verticalFromParent.style.top = parentBottomY + 'px';
                                verticalFromParent.style.height = Math.max(0, connectionY - parentBottomY) + 'px'; // Vers le bas (hauteur positive)
                                verticalFromParent.style.width = '2px';
                                content.appendChild(verticalFromParent);
                                allConnections.push(verticalFromParent);
                            });
                        }
                    }
                }
            }
            
            // Dessiner les connexions descendantes (personne centrale ‚Üí enfants) avec traits √† angle droit
            if (childParentMap && childParentMap.size > 0) {
                childParentMap.forEach((childIds, parentId) => {
                    const parentCard = document.querySelector(`[data-person-id="${parentId}"]`);
                    if (!parentCard) return;
                    
                    const parentX = parseInt(parentCard.style.left) + 100; // Centre de la carte parent
                    const parentTopY = parseInt(parentCard.style.top);
                    const parentBottomY = parentTopY + 180; // Bas de la carte parent
                    
                    // R√©cup√©rer les cartes des enfants
                    const childCards = childIds
                        .map(cid => document.querySelector(`[data-person-id="${cid}"]`))
                        .filter(c => c !== null);
                    
                    if (childCards.length > 0) {
                        // Point de connexion vertical (en dessous de la carte parent)
                        const connectionY = parentBottomY + 20; // 20px en dessous du bas de la carte parent
                        
                        // Pour chaque enfant, cr√©er une connexion individuelle √† angle droit (sans croix)
                        childCards.forEach((childCard) => {
                            const cardWidth = childCard.classList.contains('child') ? 160 : 200;
                            const childX = parseInt(childCard.style.left) + (cardWidth / 2);
                            const childTopY = parseInt(childCard.style.top);
                            
                            // Ligne verticale depuis le bas de la personne centrale vers le point de connexion
                            const verticalFromParent = document.createElement('div');
                            verticalFromParent.className = 'family-connection connection-to-child';
                            verticalFromParent.style.left = (parentX - 1) + 'px';
                            verticalFromParent.style.top = parentBottomY + 'px';
                            verticalFromParent.style.height = Math.max(0, connectionY - parentBottomY) + 'px';
                            verticalFromParent.style.width = '2px';
                            content.appendChild(verticalFromParent);
                            allConnections.push(verticalFromParent);
                            
                            // Ligne horizontale depuis le parent vers l'enfant (si n√©cessaire)
                            if (Math.abs(parentX - childX) > 5) {
                                const horizontalLine = document.createElement('div');
                                horizontalLine.className = 'family-connection connection-to-child';
                                horizontalLine.style.left = Math.min(parentX, childX) + 'px';
                                horizontalLine.style.top = connectionY + 'px';
                                horizontalLine.style.width = Math.abs(parentX - childX) + 'px';
                                horizontalLine.style.height = '2px';
                                content.appendChild(horizontalLine);
                                allConnections.push(horizontalLine);
                            }
                            
                            // Ligne verticale depuis le point de connexion vers le haut de l'enfant
                            const verticalToChild = document.createElement('div');
                            verticalToChild.className = 'family-connection connection-to-child';
                            verticalToChild.style.left = (childX - 1) + 'px';
                            verticalToChild.style.top = connectionY + 'px';
                            verticalToChild.style.height = Math.max(0, childTopY - connectionY) + 'px';
                            verticalToChild.style.width = '2px';
                            content.appendChild(verticalToChild);
                            allConnections.push(verticalToChild);
                        });
                    }
                });
            }
        }

        // Animer l'apparition des cartes (sauf la carte centrale d√©j√† visible)
        function animateCards() {
            const cards = document.querySelectorAll('.genealogy-card:not(.visible)');
            // Utiliser requestAnimationFrame pour optimiser le rendu
            let index = 0;
            const animate = () => {
                if (index < cards.length) {
                    cards[index].classList.add('visible');
                    index++;
                    // Animer plusieurs cartes par frame pour acc√©l√©rer
                    if (index < cards.length) {
                        cards[index].classList.add('visible');
                        index++;
                    }
                    if (index < cards.length) {
                        requestAnimationFrame(animate);
                    }
                }
            };
            // D√©marrer l'animation
            if (cards.length > 0) {
                requestAnimationFrame(animate);
            }
        }

        // Zoom et pan
        function zoomIn() {
            currentZoom = Math.min(currentZoom * 1.2, 3);
            updateViewport();
        }

        function zoomOut() {
            currentZoom = Math.max(currentZoom / 1.2, 0.3);
            updateViewport();
        }

        function resetZoom() {
            currentZoom = 1;
            currentPanX = 0;
            currentPanY = 0;
            updateViewport();
        }

        function updateViewport() {
            const content = document.getElementById('fanContent');
            content.style.transform = `translate(${currentPanX}px, ${currentPanY}px) scale(${currentZoom})`;
            document.getElementById('zoomLevel').textContent = Math.round(currentZoom * 100) + '%';
        }

        // Centrer la vue sur une position donn√©e (utilis√© pour centrer sur la personne centrale)
        function centerOnPosition(x, y) {
            const viewport = document.getElementById('fanViewport');
            const viewportRect = viewport.getBoundingClientRect();
            const viewportWidth = viewportRect.width;
            const viewportHeight = viewportRect.height;

            const cardWidth = 200; // Largeur de la carte
            const cardHeight = 180; // Hauteur approximative de la carte

            // Centre de la carte
            const cardCenterX = x + (cardWidth / 2);
            const cardCenterY = y + (cardHeight / 2);

            // Calculer le pan n√©cessaire pour centrer la carte dans le viewport
            // On doit tenir compte du zoom actuel
            const scaledCardCenterX = cardCenterX * currentZoom;
            const scaledCardCenterY = cardCenterY * currentZoom;

            // Centrer dans le viewport
            currentPanX = (viewportWidth / 2) - scaledCardCenterX;
            currentPanY = (viewportHeight / 2) - scaledCardCenterY;

            // D√©sactiver temporairement la transition pour un centrage instantan√©
            const content = document.getElementById('fanContent');
            const originalTransition = content.style.transition;
            content.style.transition = 'none';
            
            updateViewport();
            
            // R√©activer la transition apr√®s un court d√©lai
            setTimeout(() => {
                content.style.transition = originalTransition || 'transform 0.3s ease';
            }, 50);
        }

        // Centrer la vue sur la personne centrale (m√©thode alternative utilisant le DOM)
        function centerOnCentralPerson() {
            const centralCard = document.querySelector('.genealogy-card.central');
            if (!centralCard) {
                console.warn('Carte centrale non trouv√©e');
                return;
            }

            const cardX = parseInt(centralCard.style.left) || 0;
            const cardY = parseInt(centralCard.style.top) || 0;
            centerOnPosition(cardX, cardY);
        }

        // Gestion du drag pour pan
        const viewport = document.getElementById('fanViewport');
        viewport.addEventListener('mousedown', (e) => {
            isDragging = true;
            dragStartX = e.clientX - currentPanX;
            dragStartY = e.clientY - currentPanY;
            viewport.style.cursor = 'grabbing';
        });

        document.addEventListener('mousemove', (e) => {
            if (isDragging) {
                currentPanX = e.clientX - dragStartX;
                currentPanY = e.clientY - dragStartY;
                updateViewport();
            }
        });

        document.addEventListener('mouseup', () => {
            isDragging = false;
            viewport.style.cursor = 'grab';
        });

        // Zoom avec molette
        viewport.addEventListener('wheel', (e) => {
            e.preventDefault();
            const delta = e.deltaY > 0 ? 0.9 : 1.1;
            currentZoom = Math.max(0.3, Math.min(3, currentZoom * delta));
            updateViewport();
        });

        // Mise √† jour du statut
        function updateStatus(message, type) {
            const status = document.getElementById('status');
            status.textContent = message;
            status.className = `status ${type}`;
            status.style.display = 'block';
        }

        // Initialisation
        document.addEventListener('DOMContentLoaded', () => {
            loadPersons();
            
            // Ajouter un event listener sur le select pour charger automatiquement la vue √©ventail
            const personSelect = document.getElementById('personSelect');
            personSelect.addEventListener('change', (e) => {
                const selectedPersonId = e.target.value;
                if (selectedPersonId) {
                    // Charger automatiquement la vue √©ventail pour la personne s√©lectionn√©e
                    loadFanViewForPerson(selectedPersonId);
                }
            });
            
            // V√©rifier si un personId est pass√© en param√®tre URL
            const urlParams = new URLSearchParams(window.location.search);
            const personId = urlParams.get('personId');
            if (personId) {
                personSelect.value = personId;
                setTimeout(() => {
                    loadFanViewForPerson(personId);
                }, 500);
            }
        });
    </script>
</body>
</html>
